#include <indexing.h>
#include <linux/limits.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <parser/context.h>
#include <parser/ruleset.h>
#include <stl/hashset.h>
#include <dirent.h>
#include <stl/array.h>

ArrayWrapper parse_dirs_fdoc(str path)
{
    struct dirent* ent;
    DIR* fd = opendir(path);

    if(fd == NULL) {
        fprintf(stderr, "Dir unable to open");
        exit(EXIT_FAILURE);
    }

    doc* result = NULL;
    size_t size = 0;
    while((ent = readdir(fd)) != NULL) {
        if(strcmp(ent->d_name, ".") != 0 && strcmp(ent->d_name, "..") != 0) {
            str delim = strrchr(ent->d_name, '.');
            if(strcmp((delim+1), "html") == 0) {
                if(result == NULL) {
                    ++size;
                    result = (doc*)malloc(sizeof(doc)*size);
                    char full_path[PATH_MAX] = {0};
                    strcat(full_path, path);
                    strcat(full_path, "/");
                    strcat(full_path, ent->d_name);
                    result[size-1] = doc_init(strdup(full_path));
                    printf("PUSHED: %d:%s\n", size-1, full_path);
                }else {
                    ++size;
                    result = (doc*)realloc(result, sizeof(doc)*size);

                    char full_path[PATH_MAX] = {0};
                    strcat(full_path, path);
                    strcat(full_path, "/");
                    strcat(full_path, ent->d_name);

                    result[size-1] = doc_init(strdup(full_path));
                    printf("PUSHED: %d:%s\n", size-1, full_path);
                }

                printf("%s\n", ent->d_name);
            }
        }
    }

    ArrayWrapper wrapper = (ArrayWrapper){ result, size };

    return wrapper;
}

void fill_words(ArrayWrapper wrapper)
{
    doc* docs = wrapper.data;
    size_t size = wrapper.size;

    for(size_t i = 0; i < size; i++) {
        doc doci = docs[i];
        str hstr = strdup(doci.name);
        printf("Start %d, %s\n", i, hstr);
        context_t ctx = context_init(hstr);

        set_mode(&ctx, HTML);

        configure_linking(&ctx);

        parse_func(&ctx);

        if(context_is_errors_thrown(&ctx)) {
            abort_and_dump(&ctx);
        }

        size_t cwordindex = 0;
        for(size_t j = 0; j < ctx.tokensSize; j++) {
            if(ctx.tokens[j].token_type == htmlstr) {
                docs[i].words[cwordindex++] = ctx.tokens[j].data.ident.lexeme;
                docs[i].words_size++;
            }
        }

        context_clean(&ctx);

        free(hstr);
    }
}

typedef struct {
    str doc_name;
    int used_index;
} DocToIndexMap;

int find_instances_for(int map[1024][1024],
DocToIndexMap used[], str word, str doc_name)
{

    return 0;
}

int main()
{
    char cwd[PATH_MAX] = {0};
    getcwd(cwd, PATH_MAX);

    strcat(cwd, "/cache");

    size_t p_size = strlen(cwd);

    ArrayWrapper files = parse_dirs_fdoc(cwd);

    fill_words(files);

    for(size_t filei = 0; filei < files.size; filei++) {
        doc* docs = (doc*)files.data;
        doc cDoc = docs[filei];
        for(size_t wordi = 0; wordi < cDoc.words_size; wordi++) {
            printf("Doc %ld Word %s\n", filei+1, cDoc.words[wordi]);
        }
    }


    int map[1024][1024];
    DocToIndexMap used[1024];

    doc *docs = (doc*)files.data;
    for(size_t filei = 0; filei < files.size; filei++) {
        doc *cdoc = docs[filei];

        for(size_t wordi = 0; wordi < cdoc.words_size; wordi++) {
            
        }
    }
    return 0;
}
